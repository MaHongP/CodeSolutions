(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
  (op (car sequence) (accumulate op initial (cdr sequence)))
  ))
(define (filter predicate sequence)
  (cond ((null? sequence) (list ))
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(define (enum-interval a b)
  (if (< b a)
      (list )
      (cons a (enum-interval (+ a 1) b))))
(define (flatmap proc seq)
  (accumulate append (list ) (map proc seq)))
(define (prime? x)
  (define (prime-iter x t)
    (cond ((= x 1) #f)
          ((not (< t x)) #t)
          ((= (remainder x t) 0) #f)
          (else (prime-iter x (+ t 1)))))
  (prime-iter x 2))
(define (prime-sum? pair)
  (prime? (+ (car pair) ((lambda (x) (if (not (pair? (cdr x))) (cdr x) (car (cdr x)))) pair))))
(define (make-pair-sum pair)
  (list (car pair) (cdr pair) (+ (car pair) (cdr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap (lambda(i)
                          (map (lambda(j) (cons i j))
                               (enum-interval 1 (- i 1))))
                        (enum-interval 1 n)))))
(define (remove- x seq)
  (filter (lambda (y) (not (= y x))) seq))
(define (permutation s)
  (if (null? s)
      (list (list ))
      (flatmap (lambda (x) (map (lambda (p) (cons x p)) (permutation (remove x s))))
               s)))
;Practice 2.40
(define (unique-duple n)
  (flatmap (lambda (i)
             (map (lambda (j)
                    (list i j))
                  (enum-interval 1 (- i 1)))
             )
           (enum-interval 1 n)))
;Practice 2.41
(define (unique-triple n)
  (flatmap (lambda (i)
             (flatmap (lambda(j)
                    (map (lambda (k)
                           (list k j i))
                         (enum-interval 1 (- j 1))))
                  (enum-interval 1 (- i 1))))
             (enum-interval 1 n)))
(define (triple=x? seq x)
  (= (accumulate + 0 seq) x))
(define (select-triple=x x)
  (filter (lambda (y) (triple=x? y x)) (unique-triple x)))
;Practice 2.42
;Queen-k: return kth queen
(define (queen-k k positions)
    (if (= k 1)
        (car positions)
        (queen-k (- k 1) (cdr positions))))
;Sameline: Judging whether a and b are in the same line
(define (sameline a b)
  (define (cadr x)
    (if (pair? (cdr x)) (car (cdr x)) (cdr x))) 
  (= (abs (/ (- (car b) (car a)) (- (cadr b) (cadr a)) )) 1))
;Empty-board: definition of an empty-board
(define empty-board (list (list)))
;And-list the & result of process applied to sequence
(define (and-list proc seq)
  (cond ((null? seq) #t)
        ((not (proc (car seq)) ) #f)
        (else (and-list proc (cdr seq)))))
;Safe? New adjoined queen is safe?
(define (safe? k solution)
  (define (queen-k k positions)
    (if (= k 1)
        (car positions)
        (queen-k (- k 1) (cdr positions))))
  (define (safe-1? k positions)
  (let ((queenk (queen-k k positions))
        (pro-posi (remove (queen-k k positions) positions))
        )
  (cond ((null? pro-posi) #t)
        ((and (and-list  (lambda(x) (not (= x (car queenk))))
                 (flatmap (lambda (y) (list (car y))) pro-posi ))
              (and-list (lambda(x) (not (sameline x queenk))) pro-posi))
             #t)
        (else #f))))
  (and-list (lambda(x) (safe-1? k x)) solution)
  )
;Adjoin-position: generate possible new queen position
(define (adjoin-position new-row k rest-of-queens)
  (map (lambda (x) (append x (list (list new-row k)))) rest-of-queens))

        
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enum-interval 1 board-size)))
                 (queen-cols (- k 1))
                 ))))
  (queen-cols board-size))
        
;Test
(prime-sum? (cons 1 1))
(prime-sum-pairs 10)
(permutation (list 1 2 3))
(display "Practice 2.40")
(newline)
(unique-duple 3)
(display "Practice 2.41")
(newline)
(unique-triple 4)
(triple=x? (list 2 3 4) 8)
(select-triple=x 10)
;Practice 2.42
(abs -1)
(queen-k 3 (list (list 2 1) (list 3 2) (list 1 3)))
(flatmap (lambda (x) (list (car x))) (list (list 2 1) (list 3 2) (list 1 3)))
(display "Safe-test")
(newline)
(safe? 4 (list (list (list 2 1) (list 4 2) (list 3 3) (list 1 4))))
(sameline (list 3 5) (list 2 4))
(and-list (lambda (x) ( = x 1)) (list 1 1 1 2))
(adjoin-position 1 5 (list (list (list 2 1) (list 4 2) (list 3 3) (list 1 4))))
(queens 4)